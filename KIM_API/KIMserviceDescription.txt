KIM API alpha release -- 11-Feb-2011

Description of the KIM Service routines

In the following description several constants are used:

C style: KIM_DIR, KIM_DIR_MODELS, KIM_DIR_TESTS 
		string constants defined in KIMservice.h which give the location
                of KIM directories.

FORTRAN style: integer,parameter :: kim_intptr = 4 (or 8)
                defined in KIMserviceF.F90 and defines length of integer
                variable that can be used to store CRAY pointers. Depending on
                a system it's value is 4 (on 32 bit machines) or 8 (on 62 bit
                machines).

==============================  GLOBAL METHODS  ==============================

int KIM_API_init(void * kimmdl, char * testname, char * modelname); 
	this routine creates the KIM API object that can store every pointer
        to the data described in the descriptor file for the model.  It also
        checks if variables described in descriptor files (test and models) are
        compatible with KIM standard naming convention and also if models are
        compatible with tests. It will return 1 upon successful completion or
        zero otherwise. Also if it is unsuccessful, kimmdl will have NULL
        value.

Arguments:

        void * kimmdl 
                reference pointer to KIM_API_model object (in c++ style the
                definition will be (KIM_API_model **)).

        char * testname
		null terminated character string that defines test name. The 
		routines prepends string constant KIM_DIR, KIM_DIR_TESTS to
		obtain file location of the test descriptor file (.kim)

        char * modelname
                null terminated character string that defines model name. The 
		routines prepends string constant KIM_DIR, KIM_DIR_TESTS to
		obtain file location of the test descriptor file (.kim)

Corresponding FORTRAN style interface:
        integer function kim_api_init_f(kimmdl,testname,modelname) 
			character (len=*) :: testname,modelname 
			integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_init_f


******************************************************************************

void KIM_API_allocate(void * kimmdl, intptr_t natoms, int ntypes, int * kimerror); 
	allocates memory for each variable data stored in initialized KIM API 
        objects. Will exit if an error during allocation. KIM_API_allocate should 
	not be used in conjunction with KIM_API_set_data for array data 
	(will create memory leak)

Arguments:

	void * kimmdl 
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

 	intptr_t natoms 
		total number of atoms. intptr_t is a c-style standard data is 
		used here to accommodate very large integers (64 bits)

	int ntypes 
		number of atom types.
        
        int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_allocate_f(kimmdl, natoms, ntypes,kimerr) 
            		integer(kind=kim_intptr) :: kimmdl,natoms 
            		integer  :: ntypes,kimerr 
	end subroutine kim_api_allocate_f

******************************************************************************

void KIM_API_free(void *kimmdl,int *kimerror); 
	deallocates all data allocated with KIM_API_allocate and also destroys  
	KIM API object. 

Argument:

	void * kimmdl
		reference pointer to KIM_API_model object (in c++ style the 
		definition will be (KIM_API_model **)).

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_free_f(kimmdl,kimerr) 
			integer(kind=kim_intptr) :: kimmdl
			integer::kimerr
	end subroutine kim_api_free_f

******************************************************************************

void KIM_API_print(void *kimmdl,kimerror); 
	prints to screen KIM API object: structure, data and flags. 

Argument:

 	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_print_f(kimmdl,kimerr) 
			integer(kind=kim_intptr) :: kimmdl
			integer::kimerr 
	end subroutine kim_api_print_f

******************************************************************************

void KIM_API_model_compute(void *kimmdl, int * kimerror); 
	execute "compute"  method of the model by using address of the compute 
	routine stored in KIM API object. 

Argument:

	 void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *))

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_model_compute(kimmdl,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl
			integer::kimerr
	end subroutine kim_api_model_compute

******************************************************************************

void KIM_API_get_Units(void *kimmdl, char * UnitsSystem,int * kimerror); 
	copies name of the units system currently in use to the supplied 
	string UnitSystem. 

Arguments:

 	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	char * UnitsSystem 
		null terminated character string, must be already allocated.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_get_units_f(kimmdl,UnitsSystem,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: UnitsSystem
			integer :: kimerr
	end subroutine kim_api_get_units_f

******************************************************************************
	
void KIM_API_get_originalUnits(void *kimmdl, char * UnitsSystem, int * kimerror); 
	gets name of the original units system, the system defined in the .kim 
	model descriptor file.

Arguments:

	void * kimmdl 
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	char * UnitsSystem 
		null terminated character string, must be already allocated.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_get_originalunits_f(kimmdl,UnitsSystem,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: UnitsSystem
			integer::kimerr
	end subroutine kim_api_get_originalunits_f

******************************************************************************

int KIM_API_set_Units(void *kimmdl, char * UnitsSystem,int * kimerror); 
	sets new unit system, also checks if the name of unit system among KIM 
	supported units systems. Will return 1 upon successful completion, 
	0 otherwise. 

Arguments:

	void * kimmdl 
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	char * UnitsSystem
		null terminated character string.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer function kim_api_set_units_f(kimmdl,UnitsSystem,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl
			integer::kimerr
	end function kim_api_set_units_f

******************************************************************************

void KIM_API_transform_Units_to(void *kimmdl, char * UnitsSystem, int * kimerror); 
	sets new units system and transforms all relevant data to new units 
	system from the current. The transformation is done by appropriate 
	scaling of all data that have physical dimensions.

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	char * UnitsSystem 
		null terminated character string.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_transform_units_to_f(kimmdl,UnitsSystem,kimerr) 
			integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: UnitsSystem
			integer::kimerr
	end subroutine  kim_api_transform_units_to_f

******************************************************************************

int KIM_API_isUnitS_fixed(void *kimmdl); 
	checks whether the model supports only one units system or can work 
	with multiple units systems. Returns 1 (true) if fixed units (units 
	cannot be reset), 0 otherwise. 

Argument:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

Corresponding FORTRAN style interface:
	integer function kim_api_isunits_fixed_f(kimmdl) 
        		integer(kind=kim_intptr) :: kimmdl 
	end function kim_api_isunits_fixed_f

================== ELEMENT ACCESS METHODS ROUTINES BY NAME ====================

int  KIM_API_set_data(void *kimmdl, char *nm,  intptr_t size, void *dt); 
	this routine places the pointer to the data in the KIM API object. It 
	searches the name of the data/variable and if it is in the KIM API object,
	it places the pointer to the data in the KIM API object, if the name is not
	there it returns 0 and 1 upon successful completion. Should not be used 
	in conjunction with KIM_API_allocate for array data

Arguments:

	void * kimmdl 
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *))
	
	char *nm  
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file

	intptr_t size 
		size of the data in terms of underlying elements

	void *dt  
		pointer to the data

Corresponding FORTRAN style interface:
	integer function kim_api_set_data_f(kimmdl,nm, size, dt) 
        		! dt is address (cray pointer to actual data )
        		integer(kind=kim_intptr) :: kimmdl,  size, dt 
        		character (len=*) ::nm 
	end function kim_api_set_data_f

******************************************************************************

void * KIM_API_get_data(void *kimmdl, char *nm, int * kimerror); 
		This routine returns a pointer to data in the KIM API object. 
		Using name (nm) it searches the KIM API object for the data and 
		returns it,  if it cannot find the data it returns NULL.

Arguments:

 	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *))
	
	char *nm
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer(kind=kim_intptr) function kim_api_get_data_f(kimmdl,nm,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) ::nm
			integer :: kimerr
	end function kim_api_get_data_f

******************************************************************************

intptr_t KIM_API_get_size(void *kimmdl, char *nm, int * kimerror); 
		the functionality of this routine is the same as 
		KIM_API_get_data, except it returns size of the data in terms 
		of underlying elements, if no data with name (nm) is in the KIM API 
		object, a negative value will be returned. 

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *))
	
	char *nm
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer(kind=kim_intptr) function kim_api_get_size_f(kimmdl,nm,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) ::nm
			integer::kimerr 
	end function kim_api_get_size_f 

******************************************************************************

intptr_t KIM_API_get_rank_shape(void *kimmdl, char *nm, int * shape, int * kimerror); 
	returns rank and provides shape of the data. If the name of the 
	variable/data is not in the KIM API object, a negative value will be 
	returned.

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *))
	
	char *nm
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file

	int * shape
		shape of the array data, number of integer here are equivalent 
		to the rank. Shape basically tells sizes of each indexes of the 
		array data. And shape[0] is the slowest changing index. Shape 
		has to be allocated. 

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer(kind=kim_intptr) function kim_api_get_rank_shape_f(kimmdl,nm, 
			shape,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: nm 
			integer :: kimerr
	end function kim_api_get_rank_shape_f 

******************************************************************************

void KIM_API_set2_compute(void *kimmdl, char *nm, int * kimerror); 
	sets the flag of the variable/data to compute. If the variable/data can 
	be optionally computed, setting flag to compute tells the model that 
	it should be computed.

Arguments:

	void * kimmdl 
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).
	
	char *nm
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful
	

Corresponding FORTRAN style interface:
	subroutine kim_api_set2_compute_f(kimmdl,nm,kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: nm
			integer::kimerr
	end subroutine kim_api_set2_compute_f

******************************************************************************

void KIM_API_set2_uncompute(void *kimmdl, char *nm,int * kimerror); 
	sets the flag of the variable/data to uncompute. If the variable/data 
	can be optionally computed, setting flag to uncompute tells the model 
	that it should not be computed.

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).
	
	char *nm
		null terminated string is the name of the data/variable/method 
		field exactly as it appears in the .kim descriptor file.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	subroutine kim_api_set2_uncompute_f(kimmdl,nm, kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) :: nm 
			integer::kimerr
	end subroutine kim_api_set2_uncompute_f

******************************************************************************

int KIM_API_isit_compute(void *kimmdl, char *nm, int * kimerror); 
	checks the status of compute flag.  If variable/data can be optionally 
	computed, a model can check if a test wants the variable to be computed. 
	Returned value 1 - do not compute, 0 compute. 

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).
	
	char *nm
		null terminated string is the name of the data/variable/method 
		field, exactly as it appears in the .kim descriptor file.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer function kim_api_isit_compute_f(kimmdl,nm, kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) ::nm
			integer :: kimerr 
	end function kim_api_isit_compute_f

******************************************************************************

int KIM_API_get_index(void *kimmdl, char*nm, int * kimerror); 
	gets index of the data/variable/method field in the KIM API object. 
	Index serves as integer offset that allows to speed up the KIM API 
	overhead connected with the element access routines. 

Arguments:

	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).
	
	char *nm
		null terminated string is the name of the data/variable/method  
		field exactly as it appears in the .kim descriptor file.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	integer function kim_api_get_index_f(kimmdl,nm, kimerr) 
        		integer(kind=kim_intptr) :: kimmdl 
        		character (len=*) ::nm 
			integer :: kimerr
	end function kim_api_get_index_f


******************************************************************************

int KIM_API_model_init(void * kimmdl);
	initiate model by calling init routine supplied by the model. It does use name 
	of the model stored in KIM API object (KIM API object has to be initialized with
	KIM_API_init routine. Return value will be 1 in case of success and zero otherwise.

Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).
	 
Corresponding FORTRAN style interface:
	integer function kim_api_model_init(kimmdl) 
        		integer(kind=kim_intptr) :: kimmdl
	end subroutine kim_api_model_init

******************************************************************************

void * KIM_API_get_listAtomsTypes(void * kimmdl,int * nATypes, int * error);
	gives back, as a return value, pointer to the array of fixed size text strings,
	each string is a atom/particle symbol.
	In case no Atoms Types are specified returns NULL.

Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int * nATypes
		total number of atom types. In case of error will be negative.

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful
			    -20 -- internal error in init nAtomsTypes
		
Corresponding FORTRAN style interface:
	function kim_api_get_listatomstypes(kimmdl,natypes,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listatomstypes
	    integer::natypes,error
        end function kim_api_get_listatomstypes


******************************************************************************

void * KIM_API_get_listParams(void * kimmdl,int * nVpar, int * error);
	gives back, as a return value, pointer to the array of fixed size text strings,
	each string is a name of a parameter variable. A parameter variable is the variable
	name that starts with PARAM_FREE_ or PARAM_FIXED_. Each parameter variable described in ".kim" file will be 
	initiated in KIM API object, but without check against standard.kim file.


Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int * nVpar
		total number of parameters. 

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	function kim_api_get_listparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listparams
	    integer::nvpar,error
        end function kim_api_get_listparams


******************************************************************************

void * KIM_API_get_listFreeParams(void * kimmdl,int * nVpar, int * error);
	gives back, as a return value, pointer to the array of fixed size text strings,
	each string is a name of a free parameter variable. Free parameter variable is the variable
	name that starts with PARAM_FREE_ . Each free parameter variable described in ".kim" file will be 
	initiated in KIM API object, but without check against standard.kim file.


Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int * nVpar
		total number of parameters. 

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	function kim_api_get_listfreeparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfreeparams
	    integer::nvpar,error
        end function kim_api_get_listfreeparams


******************************************************************************

void * KIM_API_get_listFixedParams(void * kimmdl,int * nVpar, int * error);
	gives back, as a return value, pointer to the array of fixed size text strings,
	each string is a name of a fixed parameter variable. Fixed parameter variable is the variable
	name that starts with PARAM_Fixed_ . Each fixed parameter variable described in ".kim" file will be 
	initiated in KIM API object, but without check against standard.kim file.


Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int * nVpar
		total number of parameters. 

	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	function kim_api_get_listfreeparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfreeparams
	    integer::nvpar,error
        end function kim_api_get_listfreeparams


******************************************************************************

void * KIM_API_get_NBC_method(void *kimmdl,int * error);
	gives back as a return value pointer afixed size text strings, that is 
	current NBC method in use by KIM_API object. NBC stands for Neighbor list
	and Boundary Condition.
 
Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).


	int * kimerror
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
	function kim_api_get_nbc_method(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_nbc_method
	    integer::error
        end function kim_api_get_nbc_method

******************************************************************************

int KIM_API_get_aTypeCode(void * kimmdl, char* atom, int * error);
	return atom type id for a given atom symbol. It will return -2 if no atom/particles
	types have been provided in ".kim" file. (Atom/particles type is specified in ".kim"
	file when the type filed is set to "spec"). It will return -1 if 
	symbol is not among supported atom symbols

Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	char * atom
		atom/particle symbol

	int * error
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful
			   -1 -- symbol is not among supported atom symbols

Corresponding FORTRAN style interface:
	integer function kim_api_get_atypecode_f(kimmdl,nm,error)
		integer(kind=kim_intptr) :: kimmdl
 		character (len=*) ::nm
		integer::error
	end function kim_api_get_atypecode_f


******************************************************************************

int KIM_API_get_full_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);

	provides standartized access to the supplied by the test neighbor list.
	Supplied by the test pointer to actual routine must have the same interface as above.
	Return values depend on result of execution:
	                 2 -- iterator has been successfully initialized
                         1 -- successful operation
                         0 -- iterator has been incremented past end of list
                        -1 -- invalid atom id requested (request out of range)
                        -2 -- invalid mode value
                        -3 -- invalid KIM_API object
			-4 -- Number of neighbors of an atom exceeds KIM_API_MAX_NEIGHBORS
 
Arguments:
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

	int mode 
		Operate in iterator or locator mode
		mode = 0  : iterator mode
		mode = 1  : locator mode

	int request
		Requested operation
		If mode = 0
		request = 0  : reset iterator (and return without neighbors)
		request = 1  : increment iterator
		If mode = 1
		request = #  : number of atom whose neighbor list is requested

	int *atom
		The number of the atom whose neighbor list is returned.
                This id value will be 0-based if the Model includes
                ZeroBasedLists in its KIM descriptor file and 1-based if
                the Model includes OneBasedLists in its KIM descriptor
                file. (The KIM api will do any necessary conversions
                behind the scenes.)
	
	int *numnei
		number of neighbors returned

	int **nei1atom
		 pointer variable which will point to list of neighbors on exit.
                 The neighbor id values stored in this list will be
                 0-based if the Model includes ZeroBasedLists in its KIM
                 descriptor file and 1-based if the Model includes
                 OneBasedLists in its KIM descriptor file. (the KIM api
                 will do any necessary conversions behind the scenes)


	double **Rij
		pointer variable which will point to the list of
                relative position vectors of the neighbors of an atom
                (including boundary conditions if applied) if they have
                been computed.


Corresponding FORTRAN style interface:
	integer function kim_api_get_full_neigh(kimmdl,mode,request, 
					atom, numnei, pnei1atom, pRij)
	  integer :: mode,request,atom,numnei
	  integer(kind=kim_intptr) :: kimmdl,
	  integer :: nei1atom(1) !  array from which neighbors are accessed
	  pointer(pnei1atom,nei1atom)! actual cray pointer associated with nei1atom
	  real*8::Rij(3,1) 
	  pointer(pRij,Rij)
	end function kim_api_get_full_neigh


******************************************************************************
int KIM_API_get_half_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);
	
	the description is the same as for  KIM_API_get_full_neigh, but gives back
	half neighboring list instead of full neighboring list


******************************************************************************

float KIM_API_get_unit_scalefactor(void * kim, char * name, int * error);
	returns the scale factor for units transformation to the standard unit system.
	Will return negative value if scale factor is not relevant: variable 
	has no physical dimension or name of variable is not in KIM API object

Arguments:	
	void * kimmdl
		pointer to KIM_API_model object (in c++ style the definition 
		will be (KIM_API_model *)).

 	char *name
		null terminated string is the name of the data/variable  
		field exactly as it appears in the .kim descriptor file.
 
	int * error
	        error code: 1 -- successful completion, 0 (or negative value) -- unsuccessful
			   -1 -- Variable has no physical dimension
			   -2 -- (internal error) Units system has  physical units "none"
			   -3 -- Variable is not in KIM API object

Corresponding FORTRAN style interface:
	real function kim_api_get_unit_scalefactor_f(kimmdl,nm,error)
		integer(kind=kim_intptr) :: kimmdl
 		character (len=*) ::nm
		integer::error
	end function kim_api_get_unit_scalefactor_f


******************************************************************************



==================ELEMENT ACCESS METHODS ROUTINES BY INDEX====================

"by index" routines have the same functionality as "by name" and the same
arguments except "char* nm" is replaced by "int I". Index of each 
data/variable/method in the KIM API object is obtained by the 
KIM_API_get_index routine.

void KIM_API_set_data_byI(void *kimmdl, int I, intptr_t size, void *dt, int *kimerror); 
void * KIM_API_get_data_byI(void *kimmdl,int I, int *kimerror); 

intptr_t KIM_API_get_size_byI(void *kimmdl, int I, int *kimerror); 
intptr_t KIM_API_get_rank_shape_byI(void *kimmdl, int I, int * shape, int *kimerror); 

void KIM_API_set2_compute_byI(void *kimmdl, int I, int *kimerror); 
void KIM_API_set2_uncompute_byI(void *kimmdl, int I, int *kimerror); 
int KIM_API_isit_compute_byI(void *kimmdl, int I, int *kimerror);

========================FORTRAN AUXILIARY ROUTINES============================

Auxiliary routines are not directly connected to KIM API, but they simplify 
handling and transforming data, for example, from cray pointers to f90 array 
pointers.

The following subroutine converts ctypeArray to fortran90 type array (pointer).
For example ctypeArrayc can be a pointee of a cray pointer. Using the subroutine 
one can cast cray pointer to the f90 array pointer.

	subroutine toRealArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor,
			n, m) 
        		implicit none 
        		integer :: n,m 
        		real*8,target :: ctypeArray(n,m) 
        		real*8,pointer ::ArrayWithDescriptor(:,:) 
       end subroutine toRealArrayWithDescriptor2d

there are also similar routines for casting cray pointers to different shapes 
and types f90 style arrays.

toIntegerArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor, n, m)
toIntegerArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)
toRealArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)

