#####################################################################################################
#
# Copyright 2011 Ellad B. Tadmor, Ryan S. Elliott, and James P. Sethna
# All rights reserved. 
#
# Author: Valeriu Smirichinski, Ryan S. Elliott, Ellad B. Tadmor
# 
#####################################################################################################

KIM API alpha release -- 11-Feb-2011

Description of the KIM Service routines:

This file provides a basic description of the KIM API functions.  For each
function the main description is for the C interface.  At the end of the
description the corresponding FORTRAN interface is provided.  The C++ interface
is always the same as the C interface, but is called as a member-function of
the KIM_API_model object whose name does not include the 'KIM_API_' part of the
C interface function name.  (For example, to call KIM_API_model_compute() in
C++, you would use the code 'mdl->model_compute()'.)

In the following description several constants are used:

C style: KIM_DIR, KIM_DIR_MODELS, KIM_DIR_TESTS 
                string constants defined in KIMservice.h which give the 
                location of KIM directories.

FORTRAN style: integer,parameter :: kim_intptr = 4 (or 8)
                defined in KIMserviceF.F90 and defines length of integer
                variable that can be used to store CRAY pointers. Depending on
                a system it's value is 4 (on 32 bit machines) or 8 (on 62 bit
                machines).

==============================  GLOBAL METHODS  ==============================

int KIM_API_init(void * kimmdl, char * testname, char * modelname); 
        this routine creates the KIM API object that can store every pointer
        to the data described in the descriptor file for the model.  It also
        checks if variables described in descriptor files (tests and models)
        are compatible with KIM standard naming convention (stored in the file
        'standard.kim') and if models are compatible with tests. It will return
        1 upon successful completion or zero otherwise. Also if it is
        unsuccessful, kimmdl will have NULL value.

Arguments:

        void * kimmdl 
                reference pointer to KIM_API_model object (in c++ style the
                definition will be (KIM_API_model **)).

        char * testname
                null terminated character string that defines test name. The 
                routine prepends string constant KIM_DIR, KIM_DIR_TESTS to
                obtain file location of the test descriptor file (.kim)

        char * modelname
                null terminated character string that defines model name. The 
                routine prepends string constant KIM_DIR, KIM_DIR_MODELS to
                obtain file location of the model descriptor file (.kim)

Corresponding FORTRAN style interface:
        integer function kim_api_init_f(kimmdl,testname,modelname) 
                        character (len=*) :: testname,modelname 
                        integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_init_f


******************************************************************************

int KIM_API_init_str_testname(void * kimmdl, char * testname, char * modelname); 
        the same as KIM_API_init, but testname is actual content of .kim file: it is a long
        character string null(char(0)) or eof terminated.

Arguments:

        void * kimmdl 
                reference pointer to KIM_API_model object (in c++ style the
                definition will be (KIM_API_model **)).

        char * testname
                null(char(0)) or eof terminated  character string with content of corresponded 
                to testname.kim.
                

        char * modelname
                null terminated character string that defines model name. The 
                routine prepends string constant KIM_DIR, KIM_DIR_MODELS to
                obtain file location of the model descriptor file (.kim)

Corresponding FORTRAN style interface:
        integer function kim_api_init_f(kimmdl,testname,modelname) 
                        character (len=*) :: testname,modelname 
                        integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_init_str_testname_f


******************************************************************************


void KIM_API_allocate(void * kimmdl, intptr_t natoms, int ntypes, int * kimerror); 
        allocates memory for each data variable stored in the initialized KIM API 
        object kimmdl. Will exit if an error occurs during allocation. 
        KIM_API_allocate will try to alloccate every data in KIM API object, for which
        size and shapes of which defined by natoms ("numberOfAtoms") or ntypes ("numberAtomTypes")
        KIM_API_allocate should not be used in conjunction with
        KIM_API_set_data for those it will create memory leak.
	One should not also call KIM_API_allocate on the same kimmdl twice (or more). 
        The correct way of reusing allocated kimmdl pointer is the following:
        1. free all memories by calling KIM_API_free()
        2. call KIM_API_init(...)
	3. call KIM_API_allocate(...) 

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        intptr_t natoms 
                total number of atoms. intptr_t is a c-style standard data type
                and is used here to accommodate very large integers (64 bits)

        int ntypes
                number of atom types.
        
        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_allocate_f(kimmdl, natoms, ntypes,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl,natoms 
                        integer  :: ntypes,kimerr 
        end subroutine kim_api_allocate_f

******************************************************************************

void KIM_API_free(void *kimmdl,int *kimerror); 
        deallocates all memory allocated by KIM_API_allocate and also destroys  
        KIM API object. 

Argument:

        void * kimmdl
                reference pointer to KIM_API_model object (in c++ style the 
                definition will be (KIM_API_model **)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_free_f(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end subroutine kim_api_free_f

******************************************************************************

void KIM_API_print(void *kimmdl,kimerror); 
        prints to the screen the KIM API object: structure, data and flags. 

Argument:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_print_f(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr 
        end subroutine kim_api_print_f

******************************************************************************

void KIM_API_model_compute(void *kimmdl, int * kimerror); 
        execute "compute" method of the model by using the address of the 
        compute routine stored in KIM API object. 

Argument:

         void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_model_compute(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end subroutine kim_api_model_compute


******************************************************************************

void KIM_API_model_destroy(void *kimmdl, int * kimerror); 
        execute "destroy" method of the model by using the address of the 
        destroy routine stored in KIM API object. 

Argument:

         void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_model_destroy(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end subroutine kim_api_model_destroy

******************************************************************************

void KIM_API_get_Units(void *kimmdl, char * UnitsSystem,int * kimerror); 
        copies the name of the units system currently in use to the supplied 
        string UnitsSystem. Character array of UnitsSytem must be already allocated 
        (or size defined) with atleast 64 bites long. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * UnitsSystem 
                null terminated character string, must be already allocated
                (atleast 64 bites long).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_get_units_f(kimmdl,UnitsSystem,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: UnitsSystem
                        integer :: kimerr
        end subroutine kim_api_get_units_f

******************************************************************************

int KIM_API_isUnitS_fixed(void *kimmdl); 
        checks whether the model supports only one units system or can work 
        with multiple units systems. Returns 1 (true) if units are fixed (units 
        cannot be reset), 0 otherwise. 

Argument:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

Corresponding FORTRAN style interface:
        integer function kim_api_isunits_fixed_f(kimmdl) 
                        integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_isunits_fixed_f

******************************************************************************

================== ELEMENT ACCESS METHODS ROUTINES BY NAME ====================

int  KIM_API_set_data(void *kimmdl, char *nm,  intptr_t size, void *dt); 
        This routine places the pointer, dt, to the data in the KIM API object
        kimmdl. It searches for the name of the data/variable, nm, and if it is 
        in the KIM API object, places the pointer dt in the KIM API object.
        Upon successful completion this routine returns 1.  If nm is not in the 
        KIM API object this routine returns 0. If memory has already been
        allocated for this argument, a memory leak will be created.  Thus, care
        must be taken if this routine is used in conjunction with
        KIM_API_allocate for array data.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm  
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        intptr_t size 
                size of the data in terms of underlying elements

        void *dt  
                pointer to the data

Corresponding FORTRAN style interface:
        integer function kim_api_set_data_f(kimmdl,nm, size, dt) 
                        ! dt is address (cray pointer to actual data )
                        integer(kind=kim_intptr) :: kimmdl,  size, dt 
                        character (len=*) ::nm 
        end function kim_api_set_data_f

******************************************************************************

void * KIM_API_get_data(void *kimmdl, char *nm, int * kimerror); 
                This routine returns a pointer to data in the KIM API object. 
                Using name (nm) it searches the KIM API object for the data and 
                returns it, if it cannot find nm it returns NULL.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_data_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer :: kimerr
        end function kim_api_get_data_f

******************************************************************************

intptr_t KIM_API_get_size(void *kimmdl, char *nm, int * kimerror); 
                The functionality of this routine is the same as 
                KIM_API_get_data, except it returns the size of the data in terms 
                of underlying elements, if no data with name (nm) is in the KIM API 
                object, a negative value will be returned. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_size_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer::kimerr 
        end function kim_api_get_size_f 

******************************************************************************

intptr_t KIM_API_get_rank_shape(void *kimmdl, char *nm, int * shape, int * kimerror); 
        This routine returns the rank of nm and provides its shape. If the name of the 
        variable/data is not in the KIM API object, a negative value will be 
        returned.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * shape
                An array of integers for the shape of the array data. The
                routine will set values in this array for each dimension of the
                data object (the number of these is equal to the rank value
                returned by this function). Shape gives range of each index for
                the array data. Shape[0] is the slowest changing index. Shape 
                has to be allocated and should have enough memory to hold a
                value for each dimension.  (An integer array of size 10 or
                greater is usually sufficient.)

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_rank_shape_f(kimmdl,nm, 
                        shape,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm 
                        integer :: kimerr
                        integer,pointer :: shape(:)
        end function kim_api_get_rank_shape_f 


******************************************************************************

void  KIM_API_set_rank_shape(void *kimmdl, char *nm, int * shape,int rank, int * kimerror); 
        This routine sets the `shape' of nm and checks if the `rank' provided
        is the same as that already stored in the KIM API object. In case of
        error, kimerror will be zero or a negative value. In case of success
        kimerror = 1.  This will overwrite all of the shape data stored in
        the KIM API object for this argument.  This routine should not be
        used in conjunction with arguments for which KIM_API_allocate() has
        previously allocated memory.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * shape
                An array of integers for the shape of the array data. The
                routine will use the values in this array for each dimension of
                the data object (the number of these must be equal to the rank
                value passed to the function). Shape gives the range of each
                index for the array data. Shape[0] is the slowest changing
                index.

        int rank
                 Rank of the array and size of shape     

        int * kimerror
                error code: 1   -- successful completion, 
                            0   -- name nm is not in KIM
                           -1   -- rank provided, does not match KIM API variable rank
                           -2   -- negative index in shape

Corresponding FORTRAN style interface:
        subroutine kim_api_set_rank_shape_f(kimmdl,nm, shape, rank, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm 
                        integer :: rank, kimerr, shape(rank)
        subroutine kim_api_aet_rank_shape_f 


******************************************************************************

void KIM_API_set2_compute(void *kimmdl, char *nm, int * kimerror); 
        sets the flag of the variable/data to compute. If the variable/data can 
        be optionally computed, setting this flag to compute tells the model that 
        it should be computed.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
        

Corresponding FORTRAN style interface:
        subroutine kim_api_set2_compute_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm
                        integer::kimerr
        end subroutine kim_api_set2_compute_f

******************************************************************************

void KIM_API_set2_donotcompute(void *kimmdl, char *nm,int * kimerror); 
        sets the flag of the variable/data to donotcompute. If the variable/data 
        can be optionally computed, setting flag to donotcompute tells the model 
        that it should not be computed.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method 
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion,
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_set2_donotcompute_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm 
                        integer::kimerr
        end subroutine kim_api_set2_donotcompute_f

******************************************************************************

int KIM_API_isit_compute(void *kimmdl, char *nm, int * kimerror); 
        checks the status of compute flag.  If variable/data can be optionally 
        computed, a model can check if a test wants the variable to be computed. 
        Returned value 0 - do not compute, 1 compute. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method 
                field, exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer function kim_api_isit_compute_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer :: kimerr 
        end function kim_api_isit_compute_f

******************************************************************************

int KIM_API_get_index(void *kimmdl, char*nm, int * kimerror); 
        This routine returns the index of the data/variable/method field in the 
        KIM API object. This index serves as an integer offset that allows for
        efficient access to the KIM API object.  (This eliminates the overhead
        in the element access routines associated with using the string nm to
        search for the data/variable/method.)

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer function kim_api_get_index_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm 
                        integer :: kimerr
        end function kim_api_get_index_f


******************************************************************************

int KIM_API_model_init(void * kimmdl);
        This routine will initialize the model associated with the kimmdl
        object by calling the init routine supplied by the model. It uses the
        model's name (which is stored in KIM API object by the KIM_API_init
        routine.)  The return value will be 1 in case of success and zero otherwise.

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
         
Corresponding FORTRAN style interface:
        integer function kim_api_model_init(kimmdl) 
                        integer(kind=kim_intptr) :: kimmdl
        end subroutine kim_api_model_init

******************************************************************************

void * KIM_API_get_listAtomTypes(void * kimmdl,int * nATypes, int * error);
        Returns a pointer to an array of fixed size text strings.  (The text
        strings are of size KEY_CHAR_LENGTH, which is a constant defined by the
        KIM API.) The memory pointed to by this pointer is allocated by the
        routine, but should be released by the user to avoid a memory leak.
        Each string is a atom/particle symbol. In the case where no atom types
        are specified by the model or test, the routine returns NULL.

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nATypes
                total number of atom types. In case of error will be negative.

        int * kimerror
                error code:   1                     -- successful completion, 
                              0 (or negative value) -- unsuccessful
                            -20                     -- internal error in init 
                                                       nAtomsTypes
                
Corresponding FORTRAN style interface:
        function kim_api_get_listatomtypes(kimmdl,natypes,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listatomtypes
            integer::natypes,error
        end function kim_api_get_listatomtypes


******************************************************************************

void * KIM_API_get_listParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a parameter variable. (The text
        strings are of size KEY_CHAR_LENGTH, which is a constant defined by the
        KIM API.)  The memory pointed to by this pointer is allocated by the
        routine, but should be released by the user to avoid a memory leak.
        A parameter variable is one whose name starts with PARAM_FREE_ or
        PARAM_FIXED_. Each parameter variable described in the ".kim" file will
        have a place in the KIM API object, but it will not be checked against
        the standard.kim file.


Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listparams
            integer::nvpar,error
        end function kim_api_get_listparams


******************************************************************************

void * KIM_API_get_listFreeParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a free parameter variable. (The text
        strings are of size KEY_CHAR_LENGTH, which is a constant defined by the
        KIM API.)  The memory pointed to by this pointer is allocated by the
        routine, but should be released by the user to avoid a memory leak.
        Free parameter variables are those whose name starts with PARAM_FREE_.
        Each free parameter variable described in a ".kim" file will have a
        place in the KIM API object, but it will not be checked against the
        standard.kim file.


Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listfreeparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfreeparams
            integer::nvpar,error
        end function kim_api_get_listfreeparams


******************************************************************************

void * KIM_API_get_listFixedParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a fixed parameter variable. (The text
        strings are of size KEY_CHAR_LENGTH, which is a constant defined by
        the KIM API.)  The memory pointed to by this pointer is allocated by
        the routine, but should be released by the user to avoid a memory leak.
        Fixed parameter variables are those whose name starts with
        PARAM_FIXED_.  Each fixed parameter variable described in a ".kim" file
        will have a place in the KIM API object, but it will not be checked 
        against the standard.kim file.

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion,
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listfixedparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfixedparams
            integer::nvpar,error
        end function kim_api_get_listfixedparams


******************************************************************************

void * KIM_API_get_NBC_method(void *kimmdl,int * error);
        Returns a pointer to a fixed size text string. (The text string is of
        size KEY_CHAR_LENGTH, which is a constant defined by the KIM API.) 
        The memory pointed to by this pointer is allocated by the routine,
        but should be released by the user to avoid a memory leak. The string
        is the current NBC method in use by the KIM_API object kimmdl. NBC
        stands for Neighbor list and Boundary Condition.
 
Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_nbc_method(kimmdl,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_nbc_method
            integer::error
        end function kim_api_get_nbc_method

******************************************************************************

int KIM_API_get_aTypeCode(void * kimmdl, char* atom, int * error);
        Returns the atom type id for a given atom symbol, as defined by the
        model associted with kimmdl.  The routine returns -2 if no atom/particle
        types have been provided in the ".kim" files. (Atom/particle types are 
        specified in the ".kim" file when the type field is set to "spec").
        The routine returns -1 if the supplied symbol, atom, is not among the
        KIM supported atom symbols. (See standard.kim for the list of supported
        atom/particle types.)

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * atom
                atom/particle symbol

        int * error
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
                           -1                     -- symbol is not among the
                                                     KIM supported atom symbols

Corresponding FORTRAN style interface:
        integer function kim_api_get_atypecode_f(kimmdl,nm,error)
                integer(kind=kim_intptr) :: kimmdl
                character (len=*) ::nm
                integer::error
        end function kim_api_get_atypecode_f

******************************************************************************

int KIM_API_get_neigh_mode(void *kimmdl,int *kimerror);

         returns back neighbor list mode for the model:
         1  -- for Iterator mode
         2  -- for Locator mode
         3  -- for Both (model needs iterator and locator mode)
         negative value - if  error

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * error
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
                           
******************************************************************************

int KIM_API_get_full_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);

        provides standartized access to the neighbor list supplied by the test.
        The test must have previously registered, in the kimmdl object, a
        pointer to its neighbor list access routine with the same interface as
        above (except that `mode' and `request' must be of type `int*').  Two
        modes are supported: `Iterator' and `Locator'.  In Iterator mode, the
         iterator should, first, be reset.  Then, a call to this funciton will
        return the neighbor list for the "next" atom (the order in which atoms
        are returned is immaterial in Iterator mode, and therefore undefined).
        This process repeats until the neighbor list of every atom has been
        returned and the iterator is incremented past the end of the list.  In
        Locator mode, the used explicitly requests the atom for which a
        neighbor list is desired.  This mode must be used when the order in
        which atom neighbor lists are processed is important. 
        The return value depends on the results of execution:
                         2 -- iterator has been successfully initialized
                         1 -- successful operation
                         0 -- iterator has been incremented past end of list
                        -1 -- invalid atom id requested (request out of range)
                        -2 -- invalid mode value
                        -3 -- invalid KIM_API object
                        -4 -- Number of neighbors of an atom exceeds KIM_API_MAX_NEIGHBORS
                        -5 -- get_full_neigh method in KIM API object is not set (NULL value)
 
Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int mode 
                Operate in iterator or locator mode
                mode = 0  : iterator mode
                mode = 1  : locator mode

        int request
                Requested operation
                If mode = 0
                    request = 0  : reset iterator (and return without neighbors)
                    request = 1  : increment iterator
                If mode = 1
                    request = #  : number of atom whose neighbor list is requested

        int *atom
                The number of the atom whose neighbor list is returned.
                This id value will be 0-based if the Model includes
                ZeroBasedLists in its KIM descriptor file and 1-based if
                the Model includes OneBasedLists in its KIM descriptor
                file. (The KIM api will do any necessary conversions
                behind the scenes.)
        
        int *numnei
                number of neighbors returned

        int **nei1atom
                 pointer variable which will point to the list of neighbors on
                 exit. The neighbor id values stored in this list will be
                 0-based if the Model includes ZeroBasedLists in its KIM
                 descriptor file and 1-based if the Model includes
                 OneBasedLists in its KIM descriptor file. (the KIM api
                 will do any necessary conversions behind the scenes)

        double **Rij
                pointer variable which will point to the list of
                relative position vectors (of `atom' relative to the neighbor,
                i.e., Rij = X_i - X_j) of the neighbors of an atom (including
                boundary conditions if applied) if they have been computed
                (NBC scenario NEIGH-RVEC-F only).  Has NULL value otherwise 
                (all other NBC scenerios).

Corresponding FORTRAN style interface:
        integer function kim_api_get_full_neigh(kimmdl,mode,request, 
                                        atom, numnei, pnei1atom, pRij)
          integer :: mode,request,atom,numnei
          integer(kind=kim_intptr) :: kimmdl,
          integer :: nei1atom(1) !  array from which neighbors are accessed
          pointer(pnei1atom,nei1atom)! actual cray pointer associated with nei1atom
          real*8::Rij(3,1) 
          pointer(pRij,Rij)
        end function kim_api_get_full_neigh


******************************************************************************
int KIM_API_get_half_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);
        
        the description is the same as for KIM_API_get_full_neigh, but this
        routine provides a half neighbor list (where only the neighbors of atom
        number `i' that have numbers greater than `i' are included in the list)
        instead of a full neighbor list.  This type of list is often more
        computationally efficient since it only stores each pair of atoms once.
        The test must have previously registered, in the kimmdl object, a
        pointer to its neighbor list access routine with the same interface as
        above (except that `mode' and `request' must be of type `int*').


******************************************************************************

==================ELEMENT ACCESS METHODS ROUTINES BY INDEX====================

"by index" routines have the same functionality as "by name" and the same
arguments except "char* nm" is replaced by "int I". Index of each 
data/variable/method in the KIM API object is obtained by the 
KIM_API_get_index routine.

void KIM_API_set_data_byI(void *kimmdl, int I, intptr_t size, void *dt, int *kimerror); 
void * KIM_API_get_data_byI(void *kimmdl,int I, int *kimerror); 

intptr_t KIM_API_get_size_byI(void *kimmdl, int I, int *kimerror); 
intptr_t KIM_API_get_rank_shape_byI(void *kimmdl, int I, int * shape, int *kimerror); 

void KIM_API_set2_compute_byI(void *kimmdl, int I, int *kimerror); 
void KIM_API_set2_donotcompute_byI(void *kimmdl, int I, int *kimerror); 
int KIM_API_isit_compute_byI(void *kimmdl, int I, int *kimerror);

========================FORTRAN AUXILIARY ROUTINES============================

Auxiliary routines are not directly connected to KIM API, but they simplify 
handling and transforming data, for example, from cray pointers to f90 array 
pointers.

The following subroutine converts ctypeArray to fortran90 type array (pointer).
For example ctypeArrayc can be a pointee of a cray pointer. Using the subroutine 
one can cast cray pointer to the f90 array pointer.

        subroutine toRealArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor,
                        n, m) 
                        implicit none 
                        integer :: n,m 
                        real*8,target :: ctypeArray(n,m) 
                        real*8,pointer ::ArrayWithDescriptor(:,:) 
       end subroutine toRealArrayWithDescriptor2d

there are also similar routines for casting cray pointers to different shapes 
and types f90 style arrays.

toIntegerArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor, n, m)
toIntegerArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)
toRealArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)

