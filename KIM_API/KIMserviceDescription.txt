KIM API alpha release -- 11-Feb-2011

Description of the KIM Service routines:

This file provides a basic description of the KIM API functions.  For each
function the main description is for the C interface.  At the end of the
description the corresponding FORTRAN interface is provided.  The C++ interface
is always the same as the C interface, but is called as a member-function of
the KIM_API_model object whose name does not include the 'KIM_API_' part of the
C interface function name.  (For example, to call KIM_API_model_compute() in
C++, you would use the code 'mdl->model_compute()'.)

In the following description several constants are used:

C style: KIM_DIR, KIM_DIR_MODELS, KIM_DIR_TESTS 
                string constants defined in KIMservice.h which give the 
                location of KIM directories.

FORTRAN style: integer,parameter :: kim_intptr = 4 (or 8)
                defined in KIMserviceF.F90 and defines length of integer
                variable that can be used to store CRAY pointers. Depending on
                a system it's value is 4 (on 32 bit machines) or 8 (on 62 bit
                machines).

==============================  GLOBAL METHODS  ==============================

int KIM_API_init(void * kimmdl, char * testname, char * modelname); 
        this routine creates the KIM API object that can store every pointer
        to the data described in the descriptor file for the model.  It also
        checks if variables described in descriptor files (tests and models)
        are compatible with KIM standard naming convention (stored in the file
        'standard.kim') and if models are compatible with tests. It will return
        1 upon successful completion or zero otherwise. Also if it is
        unsuccessful, kimmdl will have NULL value.

Arguments:

        void * kimmdl 
                reference pointer to KIM_API_model object (in c++ style the
                definition will be (KIM_API_model **)).

        char * testname
                null terminated character string that defines test name. The 
                routine prepends string constant KIM_DIR, KIM_DIR_TESTS to
                obtain file location of the test descriptor file (.kim)

        char * modelname
                null terminated character string that defines model name. The 
                routine prepends string constant KIM_DIR, KIM_DIR_MODELS to
                obtain file location of the model descriptor file (.kim)

Corresponding FORTRAN style interface:
        integer function kim_api_init_f(kimmdl,testname,modelname) 
                        character (len=*) :: testname,modelname 
                        integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_init_f


******************************************************************************

void KIM_API_allocate(void * kimmdl, intptr_t natoms, int ntypes, int * kimerror); 
        allocates memory for each data variable stored in the initialized KIM API 
        object kimmdl. Will exit if an error occurs during allocation. 
        KIM_API_allocate should not be used in conjunction with
        KIM_API_set_data for array data (this wwould create a memory leak)

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        intptr_t natoms 
                total number of atoms. intptr_t is a c-style standard data type
                and is used here to accommodate very large integers (64 bits)

        int ntypes
                number of atom types.
        
        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_allocate_f(kimmdl, natoms, ntypes,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl,natoms 
                        integer  :: ntypes,kimerr 
        end subroutine kim_api_allocate_f

******************************************************************************

void KIM_API_free(void *kimmdl,int *kimerror); 
        deallocates all memory allocated by KIM_API_allocate and also destroys  
        KIM API object. 

Argument:

        void * kimmdl
                reference pointer to KIM_API_model object (in c++ style the 
                definition will be (KIM_API_model **)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_free_f(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end subroutine kim_api_free_f

******************************************************************************

void KIM_API_print(void *kimmdl,kimerror); 
        prints to the screen the KIM API object: structure, data and flags. 

Argument:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_print_f(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr 
        end subroutine kim_api_print_f

******************************************************************************

void KIM_API_model_compute(void *kimmdl, int * kimerror); 
        execute "compute" method of the model by using the address of the 
        compute routine stored in KIM API object. 

Argument:

         void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_model_compute(kimmdl,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end subroutine kim_api_model_compute

******************************************************************************

void KIM_API_get_Units(void *kimmdl, char * UnitsSystem,int * kimerror); 
        copies the name of the units system currently in use to the supplied 
        string UnitsSystem. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * UnitsSystem 
                null terminated character string, must be already allocated.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_get_units_f(kimmdl,UnitsSystem,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: UnitsSystem
                        integer :: kimerr
        end subroutine kim_api_get_units_f

******************************************************************************
        
void KIM_API_get_originalUnits(void *kimmdl, char * UnitsSystem, int * kimerror); 
        gets the name of the original units system, the system defined in the .kim 
        model descriptor file.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * UnitsSystem 
                null terminated character string, must be already allocated.

        int * kimerror
                error code: 1                     -- successful completion,
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_get_originalunits_f(kimmdl,UnitsSystem,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: UnitsSystem
                        integer::kimerr
        end subroutine kim_api_get_originalunits_f

******************************************************************************

int KIM_API_set_Units(void *kimmdl, char * UnitsSystem,int * kimerror); 
        sets the unit system, also checks if the provided name of unit system 
        is among those units systems supported by KIM.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * UnitsSystem
                null terminated character string.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer function kim_api_set_units_f(kimmdl,UnitsSystem,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl
                        integer::kimerr
        end function kim_api_set_units_f

******************************************************************************

void KIM_API_transform_Units_to(void *kimmdl, char * UnitsSystem, int * kimerror); 
        sets the units system to UnitsSystem and transforms all relevant data
        to these units. The transformation is done by using the appropriate 
        scale factor for each set of data in kimmdl that has physical dimensions.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * UnitsSystem 
                null terminated character string.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_transform_units_to_f(kimmdl,UnitsSystem,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: UnitsSystem
                        integer::kimerr
        end subroutine  kim_api_transform_units_to_f

******************************************************************************

int KIM_API_isUnitS_fixed(void *kimmdl); 
        checks whether the model supports only one units system or can work 
        with multiple units systems. Returns 1 (true) if units are fixed (units 
        cannot be reset), 0 otherwise. 

Argument:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

Corresponding FORTRAN style interface:
        integer function kim_api_isunits_fixed_f(kimmdl) 
                        integer(kind=kim_intptr) :: kimmdl 
        end function kim_api_isunits_fixed_f

================== ELEMENT ACCESS METHODS ROUTINES BY NAME ====================

int  KIM_API_pack_pointers(void *kimmdl, int NP,
                           char *name1, char *type1, intptr_t size1, TYPE* dt1,
                           char *name2, char *type2, intptr_t size2, TYPE* dt2,
                           .
                           . (NP times)
                           .
                           char *nameNP, char *typenNP, intptr_t sizeNP, TYPE* dtNP);
        This routine places the NP pointers, dt1 through dtNP, in the KIM API
        object kimmdl.  It searches for each name of the data/variable, name1
        through nameNP, and if it is in the KIM API object and its type matches
        the supplied type, type1 through typeNP respectively, the pointers, dt1
        through dtNP, are placed in the KIM API object.  Upon successful
        completion this routine returns 1.  If a name is not in the KIM API object
        this routine prints an error message and returns 0.  This routine
        should not be used in conjunction with KIM_API_allocate for array data.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))

        int NP
                number of pointers to be packed into the KIM API object.  This
                may be any integer.  (The routine is implemented using the C 
                stdarg.h mechanism for variadic, variable number of argument,
                functions.)

        char *name1 through nameNP
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        char *type1 through typeNP
                null terminated string is the type of the data/variable/method
                field exactly as it appears in the .kim descriptor file.
                (Currently supported values are "real", "real*8", "integer", 
                "integer*8", "pointer", "method", and "dummy". However, type
                "dummy" does not have associated data and will therefore give
                an error if used with this routine.)

        intptr_t size1 through sizeNP
                size of the data in terms of underlying elements

        TYPE *dt1 through dtNP
                pointer to the data.  TYPE is the native type of dt associated
                with the type string. (So, no type-casting should be required.)

Corresponding FORTRAN style interface:
        Because FORTRAN does not support user-defined variadic functions, there
        is no FORTRAN equivalent to KIM_API_pack_pointers().  FORTRAN programs
        must use one lower-level KIM_API_set_data call (see below) for each
        pointer to be packed into the KIM API object.

******************************************************************************
 
int  KIM_API_set_data(void *kimmdl, char *nm,  intptr_t size, void *dt); 
        This routine places the pointer, dt, to the data in the KIM API object
        kimmdl. It searches for the name of the data/variable, nm, and if it is 
        in the KIM API object, places the pointer dt in the KIM API object.
        Upon successful completion this routine returns 1.  If nm is not in the 
        KIM API object this routine returns 0. This routine should not be used 
        in conjunction with KIM_API_allocate for array data.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm  
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        intptr_t size 
                size of the data in terms of underlying elements

        void *dt  
                pointer to the data

Corresponding FORTRAN style interface:
        integer function kim_api_set_data_f(kimmdl,nm, size, dt) 
                        ! dt is address (cray pointer to actual data )
                        integer(kind=kim_intptr) :: kimmdl,  size, dt 
                        character (len=*) ::nm 
        end function kim_api_set_data_f

******************************************************************************

int  KIM_API_unpack_pointers(void *kimmdl, int NP,
                             char *name1, char *type1, TYPE** dt1,
                             char *name2, char *type2, TYPE** dt2,
                             .
                             . (NP times)
                             .
                             char *nameNP, char *typenNP, TYPE** dtNP);
        This routine retrieves the NP pointers, dt1 through dtNP, from the KIM API
        object kimmdl.  It searches for each name of the data/variable, name1
        through nameNP, and if it is in the KIM API object and its type matches
        the supplied type, type1 through typeNP respectively, the pointers, dt1
        through dtNP, are set to the values stored in the KIM API object.  Upon 
        successful completion this routine returns 1.  If a name is not in the
        KIM API object this routine prints an error message and returns 0.
        This routine should not be used in conjunction with KIM_API_allocate
        for array data.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))

        int NP
                number of pointers to be packed into the KIM API object.  This
                may be any integer.  (The routine is implemented using the C 
                stdarg.h mechanism for variadic, variable number of argument,
                functions.)

        char *name1 through nameNP
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        char *type1 through typeNP
                null terminated string is the type of the data/variable/method
                field exactly as it appears in the .kim descriptor file.
                (Currently supported values are "real", "real*8", "integer", 
                "integer*8", "pointer", "method", and "dummy". However, type
                "dummy" does not have associated data and will therefore give
                an error if used with this routine.)

        TYPE **dt1 through dtNP
                pointer to the data.  TYPE is the native type of dt associated
                with the type string. (So, no type-casting should be required.)

Corresponding FORTRAN style interface:
        Because FORTRAN does not support user-defined variadic functions, there
        is no FORTRAN equivalent to KIM_API_unpack_pointers().  FORTRAN programs
        must use one lower-level KIM_API_get_data call (see below) for each
        pointer to be unpacked from the KIM API object.

******************************************************************************

void * KIM_API_get_data(void *kimmdl, char *nm, int * kimerror); 
                This routine returns a pointer to data in the KIM API object. 
                Using name (nm) it searches the KIM API object for the data and 
                returns it, if it cannot find nm it returns NULL.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_data_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer :: kimerr
        end function kim_api_get_data_f

******************************************************************************

intptr_t KIM_API_get_size(void *kimmdl, char *nm, int * kimerror); 
                The functionality of this routine is the same as 
                KIM_API_get_data, except it returns the size of the data in terms 
                of underlying elements, if no data with name (nm) is in the KIM API 
                object, a negative value will be returned. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_size_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer::kimerr 
        end function kim_api_get_size_f 

******************************************************************************

intptr_t KIM_API_get_rank_shape(void *kimmdl, char *nm, int * shape, int * kimerror); 
        This routine returns the rank of nm and provides its shape. If the name of the 
        variable/data is not in the KIM API object, a negative value will be 
        returned.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *))
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file

        int * shape
                An array of integers for the shape of the array data. The
                routine will set values in this array for each dimension of the
                data object (the number of these is equal to the rank value
                returned by this function). Shape gives range of each index for
                the array data. Shape[0] is the slowest changing index. Shape 
                has to be allocated and should have enough memory to hold a
                value for each dimension.  (An integer array of size 10 or
                greater is usually sufficient.)

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer(kind=kim_intptr) function kim_api_get_rank_shape_f(kimmdl,nm, 
                        shape,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm 
                        integer :: kimerr
        end function kim_api_get_rank_shape_f 

******************************************************************************

void KIM_API_set2_compute(void *kimmdl, char *nm, int * kimerror); 
        sets the flag of the variable/data to compute. If the variable/data can 
        be optionally computed, setting this flag to compute tells the model that 
        it should be computed.

Arguments:

        void * kimmdl 
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
        

Corresponding FORTRAN style interface:
        subroutine kim_api_set2_compute_f(kimmdl,nm,kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm
                        integer::kimerr
        end subroutine kim_api_set2_compute_f

******************************************************************************

void KIM_API_set2_donotcompute(void *kimmdl, char *nm,int * kimerror); 
        sets the flag of the variable/data to donotcompute. If the variable/data 
        can be optionally computed, setting flag to donotcompute tells the model 
        that it should not be computed.

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method 
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion,
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        subroutine kim_api_set2_donotcompute_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) :: nm 
                        integer::kimerr
        end subroutine kim_api_set2_donotcompute_f

******************************************************************************

int KIM_API_isit_compute(void *kimmdl, char *nm, int * kimerror); 
        checks the status of compute flag.  If variable/data can be optionally 
        computed, a model can check if a test wants the variable to be computed. 
        Returned value 1 - do not compute, 0 compute. 

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method 
                field, exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer function kim_api_isit_compute_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm
                        integer :: kimerr 
        end function kim_api_isit_compute_f

******************************************************************************

int KIM_API_get_index(void *kimmdl, char*nm, int * kimerror); 
        This routine returns the index of the data/variable/method field in the 
        KIM API object. This index serves as an integer offset that allows for
        efficient access to the KIM API object.  (This eliminates the overhead
        in the element access routines associated with using the string nm to
        search for the data/variable/method.)

Arguments:

        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
        
        char *nm
                null terminated string is the name of the data/variable/method  
                field exactly as it appears in the .kim descriptor file.

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        integer function kim_api_get_index_f(kimmdl,nm, kimerr) 
                        integer(kind=kim_intptr) :: kimmdl 
                        character (len=*) ::nm 
                        integer :: kimerr
        end function kim_api_get_index_f


******************************************************************************

int KIM_API_model_init(void * kimmdl);
        This routine will initialize the model associated with the kimmdl
        object by calling the init routine supplied by the model. It uses the
        model's name (which is stored in KIM API object by the KIM_API_init
        routine.)  The return value will be 1 in case of success and zero otherwise.

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).
         
Corresponding FORTRAN style interface:
        integer function kim_api_model_init(kimmdl) 
                        integer(kind=kim_intptr) :: kimmdl
        end subroutine kim_api_model_init

******************************************************************************

void * KIM_API_get_listAtomsTypes(void * kimmdl,int * nATypes, int * error);
        Returns a pointer to an array of fixed size text strings.  The memory
        pointed to by this pointer is allocated by the routine, but should be
        released by the user to avoid a memory leak. Each string 
        is a atom/particle symbol. In the case where no atom types are
        specified by the model or test, the routine returns NULL.

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nATypes
                total number of atom types. In case of error will be negative.

        int * kimerror
                error code:   1                     -- successful completion, 
                              0 (or negative value) -- unsuccessful
                            -20                     -- memory has been corrupted
                                                       previously by some part
                                                       of the code (sould
                                                       never happen)
Corresponding FORTRAN style interface:
        function kim_api_get_listatomstypes(kimmdl,natypes,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listatomstypes
            integer::natypes,error
        end function kim_api_get_listatomstypes


******************************************************************************

void * KIM_API_get_listParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a parameter variable. The memory
        pointed to by this pointer is allocated by the routine, but should be
        released by the user to avoid a memory leak. A parameter variable
        is one whose name starts with PARAM_FREE_ or PARAM_FIXED_. Each
        parameter variable described in the ".kim" file will have a place in 
        the KIM API object, but it will not be checked against the standard.kim file.


Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listparams
            integer::nvpar,error
        end function kim_api_get_listparams


******************************************************************************

void * KIM_API_get_listFreeParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a free parameter variable. The memory
        pointed to by this pointer is allocated by the routine, but should be
        released by the user to avoid a memory leak. Free parameter
        variables are those whose name starts with PARAM_FREE_ . Each free
        parameter variable described in a ".kim" file will have a place in the 
        KIM API object, but it will not be checked against the standard.kim file.


Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listfreeparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfreeparams
            integer::nvpar,error
        end function kim_api_get_listfreeparams


******************************************************************************

void * KIM_API_get_listFixedParams(void * kimmdl,int * nVpar, int * error);
        Returns a pointer to an array of fixed size text strings,
        each string is the name of a fixed parameter variable. The memory
        pointed to by this pointer is allocated by the routine, but should be
        released by the user to avoid a memory leak. Fixed parameter
        variables are those whose name starts with PARAM_FIXED_. Each fixed
        parameter variable described in a ".kim" file will have a place in the 
        KIM API object, but it will not be checked against the standard.kim file.


Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * nVpar
                total number of parameters. 

        int * kimerror
                error code: 1                     -- successful completion,
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_listfreeparams(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_listfreeparams
            integer::nvpar,error
        end function kim_api_get_listfreeparams


******************************************************************************

void * KIM_API_get_NBC_method(void *kimmdl,int * error);
        Returns a pointer to a fixed size text string. The memory
        pointed to by this pointer is allocated by the routine, but should be
        released by the user to avoid a memory leak. The string is the
        current NBC method in use by the KIM_API object kimmdl. NBC stands for
        Neighbor list and Boundary Condition.
 
Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int * kimerror
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful

Corresponding FORTRAN style interface:
        function kim_api_get_nbc_method(kimmdl,nvpar,error)
            integer(kind=kim_intptr) :: kimmdl,kim_api_get_nbc_method
            integer::error
        end function kim_api_get_nbc_method

******************************************************************************

int KIM_API_get_aTypeCode(void * kimmdl, char* atom, int * error);
        Returns the atom type id for a given atom symbol, as defined by the
        model associted with kimmdl.  The routine returns -2 if no atom/particle
        types have been provided in the ".kim" files. (Atom/particle types are 
        specified in the ".kim" file when the type field is set to "spec").
        The routine returns -1 if the supplied symbol, atom, is not among the
        KIM supported atom symbols. (See standard.kim for the list of supported
        atom/particle types.)

Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char * atom
                atom/particle symbol

        int * error
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
                           -1                     -- symbol is not among the
                                                     KIM supported atom symbols

Corresponding FORTRAN style interface:
        integer function kim_api_get_atypecode_f(kimmdl,nm,error)
                integer(kind=kim_intptr) :: kimmdl
                character (len=*) ::nm
                integer::error
        end function kim_api_get_atypecode_f


******************************************************************************

int KIM_API_get_full_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);

        provides standartized access to the neighbor list supplied by the test.
        The test must have previously registered, in the kimmdl object, a
        pointer to its neighbor list access routine with the same interface as
        above.
        The return value depends on the results of execution:
                         2 -- iterator has been successfully initialized
                         1 -- successful operation
                         0 -- iterator has been incremented past end of list
                        -1 -- invalid atom id requested (request out of range)
                        -2 -- invalid mode value
                        -3 -- invalid KIM_API object
                        -4 -- Number of neighbors of an atom exceeds KIM_API_MAX_NEIGHBORS
 
Arguments:
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        int mode 
                Operate in iterator or locator mode
                mode = 0  : iterator mode
                mode = 1  : locator mode

        int request
                Requested operation
                If mode = 0
                    request = 0  : reset iterator (and return without neighbors)
                    request = 1  : increment iterator
                If mode = 1
                    request = #  : number of atom whose neighbor list is requested

        int *atom
                The number of the atom whose neighbor list is returned.
                This id value will be 0-based if the Model includes
                ZeroBasedLists in its KIM descriptor file and 1-based if
                the Model includes OneBasedLists in its KIM descriptor
                file. (The KIM api will do any necessary conversions
                behind the scenes.)
        
        int *numnei
                number of neighbors returned

        int **nei1atom
                 pointer variable which will point to the list of neighbors on
                 exit. The neighbor id values stored in this list will be
                 0-based if the Model includes ZeroBasedLists in its KIM
                 descriptor file and 1-based if the Model includes
                 OneBasedLists in its KIM descriptor file. (the KIM api
                 will do any necessary conversions behind the scenes)

        double **Rij
                pointer variable which will point to the list of
                relative position vectors of the neighbors of an atom
                (including boundary conditions if applied) if they have
                been computed (NBC scenario NEIGH-RVEC-F only).  Has NULL value
                otherwise (all other NBC scenerios).


Corresponding FORTRAN style interface:
        integer function kim_api_get_full_neigh(kimmdl,mode,request, 
                                        atom, numnei, pnei1atom, pRij)
          integer :: mode,request,atom,numnei
          integer(kind=kim_intptr) :: kimmdl,
          integer :: nei1atom(1) !  array from which neighbors are accessed
          pointer(pnei1atom,nei1atom)! actual cray pointer associated with nei1atom
          real*8::Rij(3,1) 
          pointer(pRij,Rij)
        end function kim_api_get_full_neigh


******************************************************************************
int KIM_API_get_half_neigh(void *kimmdl,int mode,int request,
        int *atom, int *numnei, int **nei1atom, double **Rij);
        
        the description is the same as for KIM_API_get_full_neigh, but this 
	routine provides a half neighbor list instead of a full neighbor list.
        The test must have previously registered, in the kimmdl object, a
        pointer to its neighbor list access routine with the same interface as
        above.


******************************************************************************

float KIM_API_get_unit_scalefactor(void * kim, char * name, int * error);
        returns the scale factor for transforming units to the standard unit
        system. Will return negative value if scale factor is not relevant: for
        example, if the variable has no physical dimension or the name of the
        variable is not in KIM API object

Arguments:      
        void * kimmdl
                pointer to KIM_API_model object (in c++ style the definition 
                will be (KIM_API_model *)).

        char *name
                null terminated string is the name of the data/variable  
                field exactly as it appears in the .kim descriptor file.
 
        int * error
                error code: 1                     -- successful completion, 
                            0 (or negative value) -- unsuccessful
                           -1                     -- Variable has no physical dimension
                           -2                     -- (internal error) Units system has
                                                     physical units "none"
                           -3                     -- Variable is not in KIM API object

Corresponding FORTRAN style interface:
        real function kim_api_get_unit_scalefactor_f(kimmdl,nm,error)
                integer(kind=kim_intptr) :: kimmdl
                character (len=*) ::nm
                integer::error
        end function kim_api_get_unit_scalefactor_f


******************************************************************************



==================ELEMENT ACCESS METHODS ROUTINES BY INDEX====================

"by index" routines have the same functionality as "by name" and the same
arguments except "char* nm" is replaced by "int I". Index of each 
data/variable/method in the KIM API object is obtained by the 
KIM_API_get_index routine.

void KIM_API_set_data_byI(void *kimmdl, int I, intptr_t size, void *dt, int *kimerror); 
void * KIM_API_get_data_byI(void *kimmdl,int I, int *kimerror); 

intptr_t KIM_API_get_size_byI(void *kimmdl, int I, int *kimerror); 
intptr_t KIM_API_get_rank_shape_byI(void *kimmdl, int I, int * shape, int *kimerror); 

void KIM_API_set2_compute_byI(void *kimmdl, int I, int *kimerror); 
void KIM_API_set2_donotcompute_byI(void *kimmdl, int I, int *kimerror); 
int KIM_API_isit_compute_byI(void *kimmdl, int I, int *kimerror);

========================FORTRAN AUXILIARY ROUTINES============================

Auxiliary routines are not directly connected to KIM API, but they simplify 
handling and transforming data, for example, from cray pointers to f90 array 
pointers.

The following subroutine converts ctypeArray to fortran90 type array (pointer).
For example ctypeArrayc can be a pointee of a cray pointer. Using the subroutine 
one can cast cray pointer to the f90 array pointer.

        subroutine toRealArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor,
                        n, m) 
                        implicit none 
                        integer :: n,m 
                        real*8,target :: ctypeArray(n,m) 
                        real*8,pointer ::ArrayWithDescriptor(:,:) 
       end subroutine toRealArrayWithDescriptor2d

there are also similar routines for casting cray pointers to different shapes 
and types f90 style arrays.

toIntegerArrayWithDescriptor2d(ctypeArray, ArrayWithDescriptor, n, m)
toIntegerArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)
toRealArrayWithDescriptor1d(ctypeArray, ArrayWithDescriptor, n)

